"use strict";(self.webpackChunkmodel_viewer=self.webpackChunkmodel_viewer||[]).push([[762],{9762:(e,n,f)=>{f.r(n),f.d(n,{MmdPluginMaterial:()=>a});var o=f(5662),r=f(6561),i=f(5690),l=f(2461),s=f(9711);class a extends r.ZL{isCompatible(e){return e===o.w.WGSL}getCustomCode(e){if("vertex"===e){const e={};return e.CUSTOM_VERTEX_DEFINITIONS=l.B,e[`!${(0,i.N)("finalWorld=finalWorld*influence;")}`]=`\n                ${s.Z}\n                \n                finalWorld = (finalWorld * influence);\n            `,e}if("fragment"===e){const e={CUSTOM_FRAGMENT_DEFINITIONS:"\n                #if defined(SPHERE_TEXTURE) && defined(NORMAL)\n                    var sphereSamplerSampler: sampler;\n                    var sphereSampler: texture_2d<f32>;\n                #endif\n                #ifdef TOON_TEXTURE\n                    var toonSamplerSampler: sampler;\n                    var toonSampler: texture_2d<f32>;\n                #endif\n            ",CUSTOM_FRAGMENT_MAIN_BEGIN:"\n                #ifdef TOON_TEXTURE\n                    var toonNdl: vec3f;\n                #endif\n            "};e[`!${(0,i.N)("var diffuseColor: vec3f=uniforms.vDiffuseColor.rgb;")}`]="\n                #ifdef APPLY_AMBIENT_COLOR_TO_DIFFUSE\n                    var diffuseColor: vec3f = clamp(uniforms.vDiffuseColor.rgb + uniforms.vAmbientColor, vec3f(0.0), vec3f(1.0));\n                #else\n                    var diffuseColor: vec3f = (uniforms.vDiffuseColor.rgb);\n                #endif\n            ",e[`!${(0,i.N)("var alpha: f32=uniforms.vDiffuseColor.a;")}`]="\n                #ifdef CLAMP_ALPHA\n                    var alpha: f32 = clamp(uniforms.vDiffuseColor.a, 0.0, 1.0);\n                #else\n                    var alpha: f32 = uniforms.vDiffuseColor.a;\n                #endif\n            ",e[`!${(0,i.N)("baseColor=textureSample(diffuseSampler,diffuseSamplerSampler,fragmentInputs.vDiffuseUV+uvOffset);")}`]="\n                #if defined(DIFFUSE) && defined(TEXTURE_COLOR)\n                    baseColor = textureSample(diffuseSampler, diffuseSamplerSampler, (fragmentInputs.vDiffuseUV + uvOffset));\n                    baseColor = vec4f(\n                        mix(\n                            vec3f(1.0),\n                            baseColor.rgb * uniforms.textureMultiplicativeColor.rgb,\n                            uniforms.textureMultiplicativeColor.a\n                        ),\n                        baseColor.a\n                    );\n                    baseColor = vec4f(\n                        clamp(\n                            baseColor.rgb + (baseColor.rgb - vec3f(1.0)) * uniforms.textureAdditiveColor.a,\n                            vec3f(0.0),\n                            vec3f(1.0)\n                        ) + uniforms.textureAdditiveColor.rgb,\n                        baseColor.a\n                    );\n                #else\n                    baseColor = textureSample(diffuseSampler, diffuseSamplerSampler, (fragmentInputs.vDiffuseUV + uvOffset));\n                #endif\n            ",e[`!${(0,i.N)("struct lightingInfo\n{")}`]="\n                struct lightingInfo {\n                #ifdef TOON_TEXTURE\n                    #ifndef NDOTL\n                        ndl: f32,\n                    #endif\n                    isToon: f32,\n                #endif\n            ",e[`!${(0,i.N)("result.diffuse=ndl*diffuseColor*attenuation;")}`]="\n                #ifdef TOON_TEXTURE\n                    result.diffuse = diffuseColor * attenuation;\n                    result.ndl = ndl;\n                    result.isToon = 1.0;\n                #elif defined(IGNORE_DIFFUSE_WHEN_TOON_TEXTURE_DISABLED)\n                    result.diffuse = diffuseColor * attenuation;\n                #else\n                    result.diffuse = (ndl * diffuseColor * attenuation);\n                #endif\n            ",e[`!${(0,i.N)("diffuseBase+=info.diffuse*shadow;")}`]="\n                #ifdef TOON_TEXTURE\n                    toonNdl = vec3f(clamp(info.ndl * shadow, 0.02, 0.98));\n                    toonNdl.r = textureSample(toonSampler, toonSamplerSampler, vec2f(0.5, toonNdl.r)).r;\n                    toonNdl.g = textureSample(toonSampler, toonSamplerSampler, vec2f(0.5, toonNdl.g)).g;\n                    toonNdl.b = textureSample(toonSampler, toonSamplerSampler, vec2f(0.5, toonNdl.b)).b;\n\n                    #ifdef TOON_TEXTURE_COLOR\n                        toonNdl = mix(\n                            vec3f(1.0),\n                            toonNdl * uniforms.toonTextureMultiplicativeColor.rgb,\n                            uniforms.toonTextureMultiplicativeColor.a\n                        );\n                        toonNdl = clamp(\n                            toonNdl + (toonNdl - vec3f(1.0)) * uniforms.toonTextureAdditiveColor.a,\n                            vec3f(0.0),\n                            vec3f(1.0)\n                        ) + uniforms.toonTextureAdditiveColor.rgb;\n                    #endif\n\n                    diffuseBase += mix(info.diffuse * shadow, toonNdl * info.diffuse, info.isToon);\n                #elif defined(IGNORE_DIFFUSE_WHEN_TOON_TEXTURE_DISABLED)\n                    diffuseBase += info.diffuse;\n                #else\n                    diffuseBase += (info.diffuse * shadow);\n                #endif\n            ";const n="\n                #ifdef EMISSIVEASILLUMINATION\n                    var finalDiffuse: vec3f = clamp(diffuseBase * diffuseColor + uniforms.vAmbientColor, vec3f(0.0), vec3f(1.0)) * baseColor.rgb;\n                #else\n                #ifdef LINKEMISSIVEWITHDIFFUSE\n                    var finalDiffuse: vec3f = clamp((diffuseBase + emissiveColor) * diffuseColor + uniforms.vAmbientColor, vec3f(0.0), vec3f(1.0)) * baseColor.rgb;\n                #else\n                    var finalDiffuse: vec3f = clamp(diffuseBase * diffuseColor + emissiveColor + uniforms.vAmbientColor, vec3f(0.0), vec3f(1.0)) * baseColor.rgb;\n                #endif\n                #endif\n            ";return e[`!${(0,i.N)(n)}`]=`\n                #ifdef APPLY_AMBIENT_COLOR_TO_DIFFUSE\n                    #ifdef EMISSIVEASILLUMINATION\n                        var finalDiffuse: vec3f = clamp(diffuseBase * diffuseColor, vec3f(0.0), vec3f(1.0)) * baseColor.rgb;\n                    #else\n                        #ifdef LINKEMISSIVEWITHDIFFUSE\n                            var finalDiffuse: vec3f = clamp((diffuseBase + emissiveColor) * diffuseColor, vec3f(0.0), vec3f(1.0)) * baseColor.rgb;\n                        #else\n                            var finalDiffuse: vec3f = clamp(diffuseBase * diffuseColor + emissiveColor, vec3f(0.0), vec3f(1.0)) * baseColor.rgb;\n                        #endif\n                    #endif\n                #else\n                    ${n.replace("diffuseBase","(diffuseBase)")} // prevent regex match bug\n                #endif\n            `,e.CUSTOM_FRAGMENT_BEFORE_FOG="\n                #if defined(NORMAL) && defined(SPHERE_TEXTURE)\n                    var viewSpaceNormal: vec3f = normalize(mat3x3f(scene.view[0].xyz, scene.view[1].xyz, scene.view[2].xyz) * fragmentInputs.vNormalW);\n\n                    var sphereUV: vec2f = viewSpaceNormal.xy * 0.5 + 0.5;\n\n                    var sphereReflectionColor: vec4f = textureSample(sphereSampler, sphereSamplerSampler, sphereUV);\n                    #ifdef SPHERE_TEXTURE_COLOR\n                        sphereReflectionColor = vec4f(\n                            mix(\n                                vec3f(1.0),\n                                sphereReflectionColor.rgb * uniforms.sphereTextureMultiplicativeColor.rgb,\n                                uniforms.sphereTextureMultiplicativeColor.a\n                            ),\n                            sphereReflectionColor.a\n                        );\n                        sphereReflectionColor = vec4f(\n                            clamp(\n                                sphereReflectionColor.rgb + (sphereReflectionColor.rgb - vec3f(1.0)) * uniforms.sphereTextureAdditiveColor.a,\n                                vec3f(0.0),\n                                vec3f(1.0)\n                            ) + uniforms.sphereTextureAdditiveColor.rgb,\n                            sphereReflectionColor.a\n                        );\n                    #endif\n                    sphereReflectionColor = vec4f(sphereReflectionColor.rgb * diffuseBase, sphereReflectionColor.a);\n\n                    #ifdef SPHERE_TEXTURE_BLEND_MODE_MULTIPLY\n                        color *= sphereReflectionColor;\n                    #elif defined(SPHERE_TEXTURE_BLEND_MODE_ADD)\n                        color = vec4f(color.rgb + sphereReflectionColor.rgb, color.a);// * sphereReflectionColor.a);\n                    #endif\n                #endif\n            ",e}return null}}},5690:(e,n,f)=>{function o(e){return e.replace(/[.*+?^${}()|[\]\\]/g,"\\$&")}f.d(n,{N:()=>o})}}]);