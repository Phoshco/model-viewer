"use strict";(self.webpackChunkmodel_viewer=self.webpackChunkmodel_viewer||[]).push([[5485],{5485:(e,n,t)=>{t.r(n),t.d(n,{mmdOutlineVertexShader:()=>o}),t(2806),t(8900),t(6340),t(8217),t(7029),t(4559),t(3226),t(8258),t(9129),t(1277),t(5470),t(242),t(5197),t(1482);const i="mmdOutlineVertexShader",r="\n// Attribute\nattribute position: vec3f;\nattribute normal: vec3f;\n\n#include<bonesDeclaration>\n#include<bakedVertexAnimationDeclaration>\n\n#include<morphTargetsVertexGlobalDeclaration>\n#include<morphTargetsVertexDeclaration>[0..maxSimultaneousMorphTargets]\n\n#include<clipPlaneVertexDeclaration>\n\n// Uniform\nuniform offset: f32;\n\n#include<instancesDeclaration>\n\nuniform viewport: vec2f;\nuniform view: mat3x3f;\nuniform viewProjection: mat4x4f;\n#ifdef WORLDPOS_REQUIRED\nuniform inverseViewProjection: mat4x4f;\n#endif\n\n#ifdef ALPHATEST\nvarying vUV: vec2f;\nuniform diffuseMatrix: mat4x4f; \n#ifdef UV1\nattribute uv: vec2f;\n#endif\n#ifdef UV2\nattribute uv2: vec2f;\n#endif\n#endif\n#include<logDepthDeclaration>\n\n\n#define CUSTOM_VERTEX_DEFINITIONS\n\n@vertex\nfn main(input: VertexInputs) -> FragmentInputs {\n    var positionUpdated: vec3f = vertexInputs.position;\n    var normalUpdated: vec3f = vertexInputs.normal;\n#ifdef UV1\n    var uvUpdated: vec2f = vertexInputs.uv;\n#endif\n    #include<morphTargetsVertexGlobal>\n    #include<morphTargetsVertex>[0..maxSimultaneousMorphTargets]\n\n#include<instancesVertex>\n#include<bonesVertex>\n#include<bakedVertexAnimation>\n\n    var viewNormal: vec3f = uniforms.view * (mat3x3(finalWorld[0].xyz, finalWorld[1].xyz, finalWorld[2].xyz) * normalUpdated);\n    var projectedPosition: vec4f = uniforms.viewProjection * finalWorld * vec4f(positionUpdated, 1.0);\n    var screenNormal: vec2f = normalize(viewNormal.xy);\n    projectedPosition = vec4f(\n        projectedPosition.xy + (screenNormal / (uniforms.viewport * 0.25 /* 0.5 */) * uniforms.offset * projectedPosition.w),\n        projectedPosition.z,\n        projectedPosition.w\n    );\n\n    vertexOutputs.position = projectedPosition;\n#ifdef WORLDPOS_REQUIRED\n    var worldPos: vec4f = uniforms.inverseViewProjection * projectedPosition;\n#endif\n\n#ifdef ALPHATEST\n#ifdef UV1\n    vertexOutputs.vUV = (uniforms.diffuseMatrix * vec4f(uvUpdated, 1.0, 0.0)).xy;\n#endif\n#ifdef UV2\n    vertexOutputs.vUV = (uniforms.diffuseMatrix * vec4f(vertexInputs.uv2, 1.0, 0.0)).xy;\n#endif\n#endif\n#include<clipPlaneVertex>\n#include<logDepthVertex>\n}\n";t(9610).l.ShadersStoreWGSL[i]=r;const o={name:i,shader:r}},3226:(e,n,t)=>{t(9610).l.IncludesShadersStoreWGSL.logDepthDeclaration="#ifdef LOGARITHMICDEPTH\nuniform logarithmicDepthConstant: f32;varying vFragmentDepth: f32;\n#endif\n"},1482:(e,n,t)=>{t(9610).l.IncludesShadersStoreWGSL.logDepthVertex="#ifdef LOGARITHMICDEPTH\nvertexOutputs.vFragmentDepth=1.0+vertexOutputs.position.w;vertexOutputs.position.z=log2(max(0.000001,vertexOutputs.vFragmentDepth))*uniforms.logarithmicDepthConstant;\n#endif\n"}}]);